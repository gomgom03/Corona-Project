const numElem = document.getElementById("num"), loadStateSubElem = document.querySelector("#loadStateSub"), spinnerElem = document.getElementById("spinner"), configSimulStartElem = document.getElementById("configSimulStart"), configPartsElems = Array.prototype.slice.call(document.getElementsByClassName("configParts")), configOptionButtonElem = document.getElementById("configOptionButton"), configOptionsElem = document.getElementById("configOptions"), mapAreaTotalElem = document.getElementById("mapAreaTotal"), mapAreaTotalToggleElem = document.getElementById("mapAreaTotalToggle"), playSimulElem = document.querySelector("#playSimul"), pauseSimulElem = document.querySelector("#pauseSimul"), pauseQueueElem = document.querySelector("#pauseQueue"), fasterSimulElem = document.querySelector("#fasterSimul"), slowerSimulElem = document.querySelector("#slowerSimul"), simulSpeedTimeElem = document.querySelector("#simulSpeedTime"), nextSimulElem = document.querySelector("#nextSimul"), prevSimulElem = document.querySelector("#prevSimul"), chartCanvasElem = document.getElementById("chartCanvas"), chartCanvasCtx = chartCanvasElem.getContext("2d"), copyableDataElem = document.getElementById("copyableData"), copyDataElem = document.getElementById("copyData"), simulContainerElem = document.getElementById("simulContainer"); let savedMap, numHouses, batchId, viewInterval, totTime, maxTime, pixelSize = 250, scenes = [], frameTime = 10, curInfected = 1, endConfigResolved = !0, curLoopIndex = 0, numScenes = 0, intervalTime = 100, curSceneNum = 0, returnTime = 2, continueQueue = !0, param = {}, paramBase = { tileWidth: 3, humansPerHouseHold: 3, tRate: .4, maskDegrade: .05, asympRate: .8, tRateLoss: 3, airflow: .5, pGroc: 3 / 7, pRes: 2 / 7, pPark: 4 / 7, curfM: 7, curfN: 21, mask: !1, carryToInf: .05, washingHands: !1, chartIncrement: 120, avoidNonessential: !1, loopTimes: 1, saveScenes: !0, upperBound: !1, map: 1 }; function popupMessage(e, a) { $("#modalLabel").text(e), $("#popupBody").text(a), $("#popupModal").modal("show") } function endConfig() { endConfigResolved && (curLoopIndex++, endConfigResolved = !1, continueQueue = !1, spinnerElem.className = "d-flex justify-content-center", setTimeout(() => { batchId = Math.random().toString(32), resetAll(), world.start(), endConfigResolved = !0, spinnerElem.className = "d-none", "collapse show" === configOptionsElem.className && configOptionButtonElem.click(), param.saveScenes ? "collapse" === mapAreaTotalElem.className && mapAreaTotalToggleElem.click() : "collapse show" === mapAreaTotalElem.className && mapAreaTotalToggleElem.click(), chartData.datasetIndex++, chartData.createNewDataset(scatterChart.data.datasets) }, 1e3)) } function resetAll() { null != world.canvas && simulContainerElem.removeChild(world.canvas), world.canvas = null, world.tiles = [], world.humans = [], world.origins = { houses: [], groceries: [], restaurants: [], hospitals: [], parks: [] }, world.walkableTiles = [], world.graph = null, curInfected = 1, time = Date.now(), savedMap = null, scenes = [], continueQueue = !0, intervalTime = 100, curSceneNum = 0, clearSceneIntervals(), viewInterval = null, totTime = 0, numScenes = 0 } /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && (paramBase.tileWidth = 1), $("#popupModal").modal({ show: !1 }), configSimulStartElem.addEventListener("click", () => { param = { ...paramBase }, curLoopIndex = 0; let e = "", a = {}; if (configPartsElems.forEach(t => { let { value: r, id: n } = t; if ("" !== r) { let t = parseInt(r); switch (("e" === r || "E" === r) && (t = Math.E), n) { case "tileWidth": t >= 1 && Math.floor(t) === t ? a[n] = t : e += "<Tile Width> should be a positive integer. "; break; case "chartIncrement": t >= 1 && Math.floor(t) === t ? a[n] = 6 * t : e += "<Chart Increment> should be a positive integer. "; break; case "humansPerHouseHold": t >= 1 && Math.floor(t) === t ? a[n] = t : e += "<Humans Per Household> should be a positive integer. "; break; case "tRate": t <= 100 && t > 0 ? a[n] = t / 100 : e += "<Probability of Transmission> should be greater than 0 and at most 100. "; break; case "maskDegrade": t <= 100 && t >= 0 ? a[n] = (100 - t) / 100 : e += "<Mask Rating> should be at least 0 and at most 100. "; break; case "asympRate": t <= 100 && t >= 0 ? a[n] = t / 100 : e += "<Probability of Asymptomatic Transmission> should be at least 0 and at most 100. "; break; case "carryToInf": t <= 100 && t > 0 ? a[n] = t / 100 : e += "<Probabilty of Infection of those Carrying the Virus Every 10 Seconds> should be greater than 0 and at most 100. "; break; case "pGroc": t <= 100 && t >= 0 ? a[n] = t / 100 : e += "<Probability of Going to a Grocery Store on a Given Day> should be at least 0 and at most 100. "; break; case "pPark": t <= 100 && t >= 0 ? a[n] = t / 100 : e += "<Probability of Going to a Park on a Given Day> should be at least 0 and at most 100. "; break; case "pRes": t <= 100 && t >= 0 ? a[n] = t / 100 : e += "<Probability of Going to a Restaurant on a Given Day> should be at least 0 and at most 100. "; break; case "mask": case "washingHands": a[n] = 1 === t; break; case "avoidNonessential": 1 === t ? (a[n] = !0, a.pRes = 0, a.pPark = 0) : a[n] = !1; break; case "curfM": t <= 12 && t >= 1 && Math.floor(t) === t ? a[n] = t : e += "<Start of Day> should be an integer at least 1 and at most 12. "; break; case "curfN": t <= 22 && t >= 13 && Math.floor(t) === t ? a[n] = t : e += "<Curfew> should be an integer at least 13 and at most 22. "; break; case "loopTimes": t >= 1 && Math.floor(t) === t ? a[n] = t : e += "<Loop Times> should be a positive integer. "; break; case "saveScenes": case "upperBound": a[n] = 1 === t; break; case "map": a[n] = t; break; default: e += "Internal Error" } } }), "" === e) { for (let e in a) param[e] = a[e]; endConfig() } else popupMessage("Error", e) }); const world = { canvas: null, start: function () { this.canvas = document.createElement("canvas"); let { tileWidth: e } = param; this.canvas.width = pixelSize * e, this.canvas.height = pixelSize * e, this.context = this.canvas.getContext("2d", { alpha: !1 }), simulContainerElem.appendChild(this.canvas), createMap(), presetHumans(), createSimul() }, clear: function () { this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) }, tiles: [], humans: [], origins: { houses: [], groceries: [], restaurants: [], hospitals: [], parks: [] }, walkableTiles: [], graph: null }; function createMap() { let { map: e } = param, a = new XMLHttpRequest; a.open("GET", `./map${e}.txt`, !1), a.onreadystatechange = function () { if (4 === a.readyState && (200 === a.status || 0 == a.status)) { let e = a.responseText; createWorld(world, e) } }, a.send(null) } function createWorld(e, a) { let t = a.split("\n"); for (let e = 0; e < t.length; e++)t[e] = t[e].split("\t"); let { canvas: r, tiles: n, humans: o, context: s } = e, { tileWidth: l, humansPerHouseHold: c } = param; for (let a = 0; a < r.width / l; a++) { let n = [], o = []; for (j = 0; j < r.height / l; j++) { let r, s, c = !0, i = parseInt(t[j][a].substring(0, 1)); switch (i) { case 0: s = "#d1f797", c = !1; break; case 1: s = "black", r = "road"; break; case 2: s = "#734000", r = "houses"; break; case 3: s = "#b0db09", r = "hospitals"; break; case 4: s = "#15bd3c", r = "parks"; break; case 5: s = "#a3271c", r = "restaurants"; break; case 6: s = "#580075", r = "groceries" }-1 !== t[j][a].indexOf("o") && e.origins[r].push({ x: a, y: j }), n.push({ num: i, component: new component(l, l, s, a * l, j * l, !0), isRoad: !1, humans: [] }), o.push(!1 === c ? 0 : 1) } e.tiles.push(n), e.walkableTiles.push(o) } numHouses = world.origins.houses.length, savedMap = s.getImageData(0, 0, pixelSize * l, pixelSize * l); for (let a = 0; a < numHouses; a++)for (let t = 0; t < c; t++)o.push({ curCoords: { x: e.origins.houses[a].x, y: e.origins.houses[a].y }, curTask: "none", originCoords: { x: e.origins.houses[a].x, y: e.origins.houses[a].y }, coronaState: { has: !1, carrying: !1, asymptomatic: !1 }, atHome: !0, age: null, curPath: [], dayTasks: [] }) } function presetHumans() { let { humans: e } = world, { humansPerHouseHold: a } = param, t = Math.floor(numHouses * a * Math.random()); e[t].coronaState.has = !0, e[t].coronaState.asymptomatic = !0 } function component(e, a, t, r, n, o) { this.width = e, this.height = a, this.x = r, this.y = n, this.color = t, ctx = world.context, this.update = (() => { ctx.fillStyle = this.color, ctx.fillRect(this.x, this.y, this.width, this.height) }), o && this.update() } function pathFind(e, a, t) { let r = new Graph(world.walkableTiles), n = r.grid[a.curCoords.x][a.curCoords.y], o = r.grid[t.x][t.y], s = astar.search(r, n, o), l = []; for (let e = 0; e < s.length; e++)l.push({ x: s[e].x, y: s[e].y }); 0 !== l.length ? a.curPath = l : "goHomeF" === a.curTask ? a.curTask = "wanderF" : a.curTask = "none" } function findShortest(e, a) { let t, r = Math.ceil(pixelSize * Math.sqrt(2)); for (let n = 0; n < a.length; n++) { let o = a[n], s = quadFormula(e.x, e.y, o.x, o.y); s < r && (t = o, r = s) } return t } function quadFormula(e, a, t, r) { return Math.sqrt(Math.pow(t - e, 2) + Math.pow(r - a, 2)) } function randTest(e) { return Math.random() < e } function moveHuman(e, a) { world.tiles[e.curCoords.x][e.curCoords.y].humans = []; let { washingHands: t } = param, { curTask: r } = e; if ("none" === r) assignTask(e, a); else if ("wander" === r || "wanderF" === r) { let t, n = world.tiles[e.curCoords.x][e.curCoords.y].num, o = [[1, 0], [0, 1], [-1, 0], [0, -1]]; o = randSort(o); let s = 0, l = 0; for (t = 0; t < o.length; t++) { let a = o[t][0], r = o[t][1]; if (null != world.tiles[e.curCoords.x + a] && null != world.tiles && n === world.tiles[e.curCoords.x + a][e.curCoords.y + r].num) { s = a, l = r; break } } e.curCoords.x += s, e.curCoords.y += l, "wanderF" !== r && randTest(.005) && (randTest(.5) ? (e.curTask = "goHome", setPath(e, e.curTask)) : assignTask(e, a)) } else e.curCoords = e.curPath[0], e.curPath.shift(), 0 === e.curPath.length && ("goHomeF" === r ? (e.coronaState.carrying && t && (e.coronaState.carrying = !1), e.curTask = "wanderF") : "hospitals" === r ? world.humans.splice(world.humans.indexOf(e), 1) : ("goHome" === r && e.coronaState.carrying && t && (e.coronaState.carrying = !1), e.curTask = "none")); world.tiles[e.curCoords.x][e.curCoords.y].humans.push(e), e.atHome ? 2 !== world.tiles[e.curCoords.x][e.curCoords.y].num && (e.atHome = !1) : 2 === world.tiles[e.curCoords.x][e.curCoords.y].num && (e.atHome = !0) } function assignTask(e, a) { let t = e.dayTasks.length, r = t * a; 0 === t && (e.curTask = "wander"), randTest(r) ? (e.curTask = e.dayTasks[0], e.dayTasks.shift(), setPath(e, e.curTask)) : e.curTask = "wander" } function setPath(e, a) { let { walkableTiles: t } = world; "goHome" === a || "goHomeF" === a ? e.atHome ? e.curTask = "none" : pathFind(t, e, e.originCoords) : pathFind(t, e, findShortest(e.curCoords, world.origins[a])) } function setTasks(e) { let { pGroc: a, pRes: t, pPark: r } = param; e.forEach(e => { let n = []; randTest(a) && n.push("groceries"), randTest(t) && n.push("restaurants"), randTest(r) && n.push("parks"), n = randSort(n), e.dayTasks = n, e.curTask = "none" }) } function randSort(e) { let a, t, r = e.length; for (; 0 !== r;)t = Math.floor(Math.random() * r), a = e[r -= 1], e[r] = e[t], e[t] = a; return e } function infect(e) { let { coronaState: a, curCoords: t } = e, { tRate: r, maskDegrade: n, asympRate: o, mask: s, carryToInf: l } = param; if (!a.has) if (!0 === a.carrying) randTest(l) && (a.carrying = !1, a.has = !0, a.asymptomatic = randTest(o), a.asymptomatic || (e.curTask = "hospitals", setPath(e, e.curTask)), curInfected++); else for (let e = -1; e <= 1; e++)for (let o = -1; o <= 1; o++) { let l = t.x + e, c = t.y + o; if (!(l < 0 || l >= pixelSize || c < 0 || c >= pixelSize || world.tiles[l][c].num !== world.tiles[t.x][t.y].num)) { let e; e = s ? r * n : r, world.tiles[l][c].humans.forEach(t => { t.coronaState.has && randTest(e) && (a.carrying = !0) }) } } } function createSimul() { let { tRate: e, maskDegrade: a, asympRate: t, tRateLoss: r, airflow: n, pGroc: o, pRes: s, pPark: l, curfM: c, curfN: i, humansPerHouseHold: u, loopTimes: d, saveScenes: m, upperBound: h } = param; totTime = 0; let p = 0, f = 3600 * (i - c) / frameTime; maxTime = 3600 * (i - c + Math.ceil(pixelSize * returnTime * frameTime / 3600)) / frameTime; let g = async (e, a, t, r) => { 0 === e && setTasks(world.humans); let n = []; function o(e) { let a = {}; return Object.assign(a, e.curCoords), e.coronaState.has ? e.coronaState.asymptomatic ? a.coronaState = "HA" : a.coronaState = "HX" : e.coronaState.carrying ? a.coronaState = "C" : a.coronaState = "N", a } return e === a ? world.humans.forEach(a => { moveHuman(a, e / t), a.curTask = "goHomeF", setPath(a, "goHomeF"), n.push(o(a)) }) : world.humans.forEach(a => { moveHuman(a, e / t), n.push(o(a)) }), loadStateSubElem.textContent = numScenes, world.humans.forEach(e => infect(e)), { scene: n, id: r } }; !async function e() { g(p, f, maxTime, batchId).then(a => { curInfected < numHouses * u && a.id === batchId && (h && 14 * (i - c + 2) * 60 * 6 > numScenes || !h) ? (m && scenes.push(a.scene), numScenes++, addScatter(), setTimeout(() => { totTime++, ++p === maxTime && (p = 0), continueQueue && e() }, 1)) : (addScatter(!0), curLoopIndex < d && endConfig()) }) }() } let updateWorld = () => { let { tileWidth: e, curfM: a, curfN: t } = param; if (scenes.length < curSceneNum + 1) return void (null !== viewInterval && (clearInterval(viewInterval), viewInterval = null)); world.clear(), world.context.putImageData(savedMap, 0, 0), scenes[curSceneNum].forEach(a => { let t; switch (a.coronaState) { case "HA": t = "#fb00ff"; break; case "HX": t = "red"; break; case "C": t = "#ffa100"; break; case "N": t = "white"; break; default: t = "white" }new component(e, e, t, a.x * e, a.y * e, !0) }); let r = curSceneNum * frameTime, n = (r = Math.floor(r / 60)) % 60, o = (r = Math.floor(r / 60)) % (t - a + returnTime) + a, s = r = Math.floor(r / (t - a + returnTime)); numElem.textContent = `Day ${s}, ${o < 10 ? "0" + o : o}:${n < 10 ? "0" + n : n}, t = ${curSceneNum}` }; function clearSceneIntervals() { null !== viewInterval && clearInterval(viewInterval) } function startSceneIntervals() { viewInterval = setInterval(() => { updateWorld(), curSceneNum++ }, intervalTime) } nextSimulElem.addEventListener("click", () => { clearSceneIntervals(), curSceneNum++, updateWorld() }), prevSimulElem.addEventListener("click", () => { clearSceneIntervals(), curSceneNum--, updateWorld() }), playSimulElem.addEventListener("click", () => { startSceneIntervals() }), pauseSimulElem.addEventListener("click", () => { clearSceneIntervals(), viewInterval = null }), pauseQueueElem.addEventListener("click", () => { continueQueue = !1 }), fasterSimulElem.addEventListener("click", () => { (intervalTime -= 10) < 10 && (intervalTime = 10), clearSceneIntervals(), startSceneIntervals() }), slowerSimulElem.addEventListener("click", () => { intervalTime += 10, clearSceneIntervals(), startSceneIntervals() }), copyDataElem.addEventListener("click", () => { let e = "x"; for (let a = 0; a < chartData.datasetIndex + 1; a++)e += `\tDataset ${a + 1}`; e += "\n"; for (let a in chartData.dataText) { e += `${a}\t`; for (let t = 0; t < chartData.dataText[a].length; t++)e += `${chartData.dataText[a][t] || ""}\t`; e += "\n" } copyableDataElem.value = e, copyableDataElem.select(), document.execCommand("copy") ? popupMessage("Success!", "You have successfully copied the data to your clipboard.") : popupMessage("Failure.", "Unable to copy data to clipboard. Check if you have data.") }); let scatterChart = new Chart(chartCanvasCtx, { type: "scatter", data: { datasets: [] }, options: { scales: { xAxes: [{ type: "linear", position: "bottom", scaleLabel: { display: !0, labelString: "Time (Minutes)" } }], yAxes: [{ type: "linear", position: "bottom", scaleLabel: { display: !0, labelString: "Infected Population (%)" } }] } } }); const chartData = { datasetIndex: -1, dataText: {}, generateColor: function () { return "#" + (16777215 * Math.random() << 0).toString(16).padStart(6, "0") }, darkenColor: function (e) { let a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e), t = parseInt(a[1], 16), r = parseInt(a[2], 16), n = parseInt(a[3], 16); function o(e) { let a = Math.round(.5 * e).toString(16); return 1 == a.length ? "0" + a : a } return s = r, l = n, "#" + o(t) + o(s) + o(l); var s, l }, createNewDataset: function (e) { let { humansPerHouseHold: a } = param, t = this.generateColor(), r = this.darkenColor(t); e.push({ label: `Dataset ${this.datasetIndex + 1}`, borderColor: r, backgroundColor: t, data: [{ x: 0, y: curInfected / a / numHouses * 100 }] }) } }; function addScatter(e = !1) { let { humansPerHouseHold: a, chartIncrement: t, curfM: r, curfN: n } = param, o = frameTime * totTime / 60, s = curInfected / a / numHouses * 100; (e || totTime % t == 0) && (scatterChart.data.datasets[chartData.datasetIndex].data.push({ y: s, x: o }), scatterChart.update(), null == chartData.dataText[o] && (chartData.dataText[o] = []), chartData.dataText[o][chartData.datasetIndex] = s) }